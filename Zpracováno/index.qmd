---
id: index
aliases: []
tags: []
---
# Úvod

Předmět **4IZ431 - Algoritmy umělé inteligence** pro mě nebyl jen o tom "splnit a zapomenout". Jelikož bych rád rozšiřoval svoje dostupné nástroje pro chytrou automatizaci, a předpokládám že prohledávání stavového prostoru by v tom mohlo hrát poměrně výraznou roli. Pochopení samotného algoritmu je však jen prvním krokem k hlubšímu pochopení vlastností dané metody. 
- [ ] Hádám, že vyučující tohoto předmětu sdílejí podobný názor, jelikož prvním z úkolů bylo simulovat prohledávání ručně, konkrétně do hloubky 6 v anglické dámě. Pro řešení však zvolili velmi příhodnou situaci, takže reálně zajímavý z hlediska vítězství je jen poměrně limitovaný prostor, takže i ručně by nebylo přespříliš komplikované zadání splnit. 
Nicméně to nebylo zase tak přímočaré jak by se čtenáři, s problematikou neobeznámeným, mohlo zatím jevit. Aby bylo vůbec možné požadovaný algoritmus provést, je nutné mít tzv. "value funkci". Taková funkce bere jako vstup stav v jednom konkrétním okamžiku a přiřazuje mu konkrétní číselnou hodnotu, díky které můžeme vůbec od sebe odlišit co je dobré a co nikoliv. A jelikož to má být stejná funkce která bude fungovat stejně dobře na odlišné situace, dokáže takovýto úkol celkem zrádný.
Zejména při manuálním provedení kdy se člověk chce za každou cenu vyhnout tomu aby musel postupně zadávat do kalkulačky (i kdybych už měl kalkulačku která umí počítat mojí value funkci přímo ze stavu, a nemusel bych ručně vyhodnocovat všechny výpočty které obsahuje jeden jediný stav) všechny možné stavy v hloubce 6. I kdyby se podařila nejlepší varianta alphabeta průchodu a byla jich jen polovina je to příliš, teda aspoň na můj vkus na manuální činnost. 
Každopádně, čím náročnější bude provést jeden průchod, tím méně experimentování se samotnou value funkcí zvládnu/budu ochoten udělat. Což považuju za suboptimální v případě kdy jsem si chtěl prohledávání stav. prostoru alespoň decentně osahat. 

Samozřejmě, mohli byste namítnout, že k tomu by byl lépe uzpůsobený druhý úkol, jenž už zahrnoval algoritmy v jejich přirozenějším prostředí. 
Bylo jím cvičení vytvořené na univerzitě v Berkley jenž se zaměřovala na programování Pacmana.
Pro tento úkol poskytovala už připravenou codebase do které stačilo napsat svoji logiku a testovat ji připravenými testy dokud nebyla v pořádku. Což není na překážku, právě naopak. Z hlediska možnosti osahat si vliv value funkce je to ideální prostředí.

Nicméně i předchozí úkol jsem chtěl vyřešit. Jeho zadáním však bylo prakticky "Navrhni vhodnou value funkci pro řešení zadáné koncovky a simuluj manuálně". Chápu že pro pochopení algoritmu je to neocenitená didaktická pomůcka. Pokud však mám dát dohromady "vhodnou value funkci pro řešení koncovky"  (interpretuji jako výhru) tak bych měl před odevzdáním vědět že to je opravdu ta správná. 
K tomu ale potřebuji najít vhodné metriky, vhodnou váhu pro každý z nich a potom ty stavy... 
Jakože problém velkého objemu stavů jsem vyřešil při manuálním dohrání a vizualizaci prohledaných stavů. Díky tomu jsem věděl, že pokud jsem se nedopustil chybné interpretace pravidel, nalezl jsem klíčový identifikátor úspěchu v postupu hrou přesně na šesté úrovni hloubky jak bylo zadáno a i následně v rámci dalších cca čtyř kol i finální vítězstí pro bílého. 
Takže s nejvyšší pravděpodobností jsem měl to řešení které jsem potřeboval, nicméně mohl jsem si být už teď jistý, že v nějaké jiné větvi něž v té jedné dvou variantách co jsem si nakreslil není také výhra a třeba ještě někde blíž. Měl jsem sice pocit že je to vysoce nepravděpodobné avšak potvrdit jsem to mohl jen provedením požadovaného algoritmu který vyžadoval právě tu value funkci.
Jako překážku jsem vnímal skutečnost, že abych potvrdil správnost nalezeného řešení musím projít algoritmus. Abych mohl projít algoritmus efektivně bez toho aniž bych musel vyhodnocovat nemalé množstí stavů, předpokládaně opakovaně protože netrefím vhodnou matematizaci svých pozorování na první a nejspíš ani na druhý pokus. Pokud se mi nepovede na první pokus udělat dostatečně dobrou value funkci, budu muset prohledat a vyhodnotit nebo i jen nakreslit mnohem vyšší počet stavů než bylo komfortní dělat ručně. Protože klíčem u alphabeta prořezávání je právě nalezení co nejvyšší hodnoty co nejdříve, což umožní logicky eliminovat ostatní varianty.


Tahle práce shrnuje dva hlavní projekty, na kterých jsem si vyzkoušel, jak teorie vypadá, když se potká s realitou (a s autograderem). Pro mě to nebyla jen "povinná školní jízda", ale příležitost osahat si nástroje, které mohou hrát roli v inteligentní automatizaci.

## Co zde najdete?

Práce je rozdělena na dvě logické části, které kopírují postup mého učení v průběhu semestru:

### Pacman Multiagent (The Warm-up)
První kontakt s prohledáváním v prostředí UC Berkeley. Cílem bylo pochopit základy, jako je **Minimax**, **Alpha-Beta** a **Expectimax**, a získat plný počet bodů v autograderu. Byl to sice "rozjezd", ale kritický pro pochopení vlivu hodnotících funkcí v real-time prostředí.

### Anglická Dáma (The Real Deal)
Zde se teorie potkala s opravdovou frustrací. Úkolem bylo vyřešit specifickou koncovku (2 králové proti 1), což vyžadovalo mnohem hlubší ponor do návrhu heuristik, vizualizaci herních stromů a manuální simulaci. Tato část je výrazně detailnější, protože právě zde se ukázala hranice mezi "naprogramovat algoritmus" a "donutit ho vyhrát".



