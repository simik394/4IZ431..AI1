---
id: index
aliases: []
tags: []
---
# Úvod

Předmět **4IZ431 - Algoritmy umělé inteligence** pro mě nebyl jen o tom "splnit a zapomenout". Jelikož bych rád rozšiřoval svoje dostupné nástroje pro chytrou automatizaci, a předpokládám že prohledávání stavového prostoru by v tom mohlo hrát poměrně výraznou roli. Pochopení samotného algoritmu je však jen prvním krokem k hlubšímu pochopení vlastností dané metody. 
- [ ] Hádám, že vyučující tohoto předmětu sdílejí podobný názor, jelikož prvním z úkolů bylo simulovat prohledávání ručně, konkrétně do hloubky 6 v anglické dámě. Pro řešení však zvolili velmi příhodnou situaci, takže reálně zajímavý z hlediska vítězství je jen poměrně limitovaný prostor, takže i ručně by nebylo přespříliš komplikované zadání splnit. 
Nicméně to nebylo zase tak přímočaré jak by se čtenáři, s problematikou neobeznámeným, mohlo zatím jevit. Aby bylo vůbec možné požadovaný algoritmus provést, je nutné mít tzv. "value funkci". Taková funkce bere jako vstup stav v jednom konkrétním okamžiku a přiřazuje mu konkrétní číselnou hodnotu, díky které můžeme vůbec od sebe odlišit co je dobré a co nikoliv. A jelikož to má být stejná funkce která bude fungovat stejně dobře na odlišné situace, dokáže takovýto úkol celkem zrádný.
Zejména při manuálním provedení kdy se člověk chce za každou cenu vyhnout tomu aby musel postupně zadávat do kalkulačky (i kdybych už měl kalkulačku která umí počítat mojí value funkci přímo ze stavu, a nemusel bych ručně vyhodnocovat všechny výpočty které obsahuje jeden jediný stav) všechny možné stavy v hloubce 6. I kdyby se podařila nejlepší varianta alphabeta průchodu a byla jich jen polovina je to příliš, teda aspoň na můj vkus na manuální činnost. 
Každopádně, čím náročnější bude provést jeden průchod, tím méně experimentování se samotnou value funkcí zvládnu/budu ochoten udělat. Což považuju za suboptimální v případě kdy jsem si chtěl prohledávání stav. prostoru alespoň decentně osahat. 

Samozřejmě, mohli byste namítnout, že k tomu by byl lépe uzpůsobený druhý úkol, jenž už zahrnoval algoritmy v jejich přirozenějším prostředí. 
Bylo jím cvičení vytvořené na univerzitě v Berkley jenž se zaměřovala na programování Pacmana.
Pro tento úkol poskytovala už připravenou codebase do které stačilo napsat svoji logiku a testovat ji připravenými testy dokud nebyla v pořádku. Což není na překážku, právě naopak. Z hlediska možnosti osahat si vliv value funkce je to ideální prostředí.

Nicméně i předchozí úkol jsem chtěl vyřešit. Jeho zadáním však bylo prakticky "Navrhni vhodnou value funkci pro řešení zadáné koncovky a simuluj manuálně". Chápu že pro pochopení algoritmu je to neocenitená didaktická pomůcka. Pokud však mám dát dohromady "vhodnou value funkci pro řešení koncovky"  (interpretuji jako výhru) tak bych měl před odevzdáním vědět že to je opravdu ta správná. 
K tomu ale potřebuji najít vhodné metriky, vhodnou váhu pro každý z nich a potom ty stavy... 
Jakože problém velkého objemu stavů jsem vyřešil při manuálním dohrání a vizualizaci prohledaných stavů. Díky tomu jsem věděl, že pokud jsem se nedopustil chybné interpretace pravidel, nalezl jsem klíčový identifikátor úspěchu v postupu hrou přesně na šesté úrovni hloubky jak bylo zadáno a i následně v rámci dalších cca čtyř kol i finální vítězstí pro bílého. 
Takže s nejvyšší pravděpodobností jsem měl to řešení které jsem potřeboval, nicméně mohl jsem si být už teď jistý, že v nějaké jiné větvi něž v té jedné dvou variantách co jsem si nakreslil není také výhra a třeba ještě někde blíž. Měl jsem sice pocit že je to vysoce nepravděpodobné avšak potvrdit jsem to mohl jen provedením požadovaného algoritmu který vyžadoval právě tu value funkci.
Jako překážku jsem vnímal skutečnost, že abych potvrdil správnost nalezeného řešení musím projít algoritmus. Abych mohl projít algoritmus efektivně bez toho aniž bych musel vyhodnocovat nemalé množstí stavů, předpokládaně opakovaně protože netrefím vhodnou matematizaci svých pozorování na první a nejspíš ani na druhý pokus. Pokud se mi nepovede na první pokus udělat dostatečně dobrou value funkci, budu muset prohledat a vyhodnotit nebo i jen nakreslit mnohem vyšší počet stavů než bylo komfortní dělat ručně. Protože klíčem u alphabeta prořezávání je právě nalezení co nejvyšší hodnoty co nejdříve, což umožní logicky eliminovat ostatní varianty.


Tahle práce shrnuje dva hlavní projekty, na kterých jsem si vyzkoušel, jak teorie vypadá, když se potká s realitou (a s autograderem).

## Co zde najdete?

### 1. Pacman Multiagent (The Warm-up)
Začátek semestru a taková "povinná jízda". Implementace agentů pro Pacmana v prostředí UC Berkeley. Cílem bylo hlavně pochopit základy a **procitit to se 100% skóre** v autograderu:
- **Reflex Agent**: Aby to do ničeho nenarazilo.
- **Minimax**: Aby to nehrálo úplně náhodně.
- **Alpha-Beta**: Aby to nehrálo *pomalu*.
- **Expectimax**: Aby to přežilo i proti duchům, co hrají jak po lobotomii (náhodně).

Bylo to fajn na rozjezd, ale ta pravá zábava (a frustrace) přišla až potom.

### 2. Anglická Dáma (The Real Deal)
Tohle už byla jiná liga. Dostali jsme za úkol nejen "nějak" hrát dámu, ale zaměřit se na specifickou koncovku. A to konkrétně situaci, kdy máte dva krále proti jednomu a musíte vyhrát. Zní to jednoduše? Taky jsem si to myslel.
Zde jdu mnohem víc do hloubky:
- Jak reprezentovat stav, aby se v tom dalo vyznat.
- **Ladění heuristik**: Proč "čím blíž, tím líp" prostě nestačí.
- **Simulace**: Hromada pokusů o to, jak donutit soupeře vlézt do pasti.
- A taky trochu vizualizace, protože dívat se jen na logy v terminálu je cesta k šílenství.

Tato část reportu je mnohem detailnější, protože jsem nad ní strávil násobně víc času a nervů. Ale výsledek snad stojí za to.


